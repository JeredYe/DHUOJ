/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package clientupdater;

//import client.view.frame.LoginFrame;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.ConnectException;
import java.net.HttpURLConnection;
import java.net.SocketTimeoutException;
import java.net.URL;
import java.net.URLConnection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import javax.swing.JOptionPane;
import log.Log;
import org.apache.commons.codec.binary.Base64;

/**
 *
 * @author HASEE
 */
public class UpdaterFrame extends javax.swing.JFrame {

    /**
     * Creates new form UpdaterFrame
     */
    String ipandport;
    String server_libpoint;
    String local_libpoint;  
    public boolean isworking = false;
    private int workingprogress = 0;
    public int status = 999;//999表示常态，0表示工作中，1表示工作完成并成功，-1表示出现错误
    private int net_status_SocketError = 0;//连接错误计数
    private int net_status_ConnectTimeOut = 0;//连接超时计数
    
    public UpdaterFrame( Map<String, String> localmap, Map<String, String> servermap,Map<String, String> maptodownload,String ipandport,String server_libpoint,String local_libpoint) {
       
        this.ipandport=ipandport;
        this.server_libpoint=server_libpoint;
        this.local_libpoint=local_libpoint;
        
        initComponents();
        this.setLocationRelativeTo(null);
        new Thread(new Runnable() {
            @Override
            public void run() {
                doWorks(localmap,servermap,maptodownload);
            }
        }).start();
    }
    

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        LabelMessage = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        TextAreaMessage = new javax.swing.JTextArea();
        EditAdress = new javax.swing.JTextField();
        progressbar = new javax.swing.JProgressBar();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        LabelMessage.setFont(new java.awt.Font("微软雅黑", 0, 18)); // NOI18N
        LabelMessage.setText("正在获取更新信息");

        TextAreaMessage.setEditable(false);
        TextAreaMessage.setColumns(20);
        TextAreaMessage.setLineWrap(true);
        TextAreaMessage.setRows(5);
        TextAreaMessage.setWrapStyleWord(true);
        jScrollPane1.setViewportView(TextAreaMessage);

        EditAdress.setText("127.0.0.1:8080");
        EditAdress.setEnabled(false);
        EditAdress.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                EditAdressActionPerformed(evt);
            }
        });

        progressbar.setToolTipText("");
        progressbar.setStringPainted(true);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(progressbar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jScrollPane1)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(LabelMessage)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 54, Short.MAX_VALUE)
                        .addComponent(EditAdress, javax.swing.GroupLayout.PREFERRED_SIZE, 192, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(LabelMessage, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(EditAdress))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(progressbar, javax.swing.GroupLayout.DEFAULT_SIZE, 21, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 166, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void EditAdressActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_EditAdressActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_EditAdressActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField EditAdress;
    private javax.swing.JLabel LabelMessage;
    private javax.swing.JTextArea TextAreaMessage;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JProgressBar progressbar;
    // End of variables declaration//GEN-END:variables

    private void doWorks(Map<String,String> localmap,Map<String,String> servermap,Map<String,String> maptodownload) {
        isworking = true;status = 0;
        Thread thworking = new Thread(new Runnable() {
            @Override
            public void run() {
                while(isworking){
                    String txt = LabelMessage.getText();
                    try {
                        if(txt.endsWith("..."))
                            txt = txt.replace("...", "");
                        else if(txt.endsWith(".."))
                            txt = txt.replace("..", "...");
                        else if(txt.endsWith("."))
                            txt = txt.replace(".", "..");
                        else if(!txt.contains("."))
                            txt = txt + ".";
                        LabelMessage.setText(txt);
                        Thread.sleep(1000);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        });
        if(!thworking.isAlive())
            thworking.start();
        try{      
            this.EditAdress.setText(ipandport);
            Map<String, String> pathMap = new HashMap<>();
            //servermap.clear();
            TextAreaMessage.setText("");
            //获取下载路径，重用保存至pathMap
            GetPath(pathMap,maptodownload,0,local_libpoint,server_libpoint);
            //3.将临时下载文件下载进入临时文件夹
           boolean got = false;//网络相关如法炮制
            while(net_status_SocketError < 2 && net_status_ConnectTimeOut < 2){
                try{
                    workingprogress = 0;//工作进度清零
                    StartDownloadFiles(pathMap,servermap,70);
                    got = true;
                    break;//无抛错直接退出循环
                }catch(Exception inner_E1){
                    System.out.println(inner_E1.getMessage()+".....InnerHTTPGetFile....downloading");
                    Log.writeExceptionLog(inner_E1.getClass() + inner_E1.getMessage());
                    if(inner_E1.getClass() == SocketTimeoutException.class){
                        net_status_ConnectTimeOut++;
                    }
                    else
                        net_status_SocketError++;
                }
            }
            if(!got)
            {
                workingprogress = 0;//工作进度清零
                StartDownloadFiles(pathMap,servermap,70);
            }
            //更替临时文件夹下的文件至具体位置
            StartReplaceFiles(pathMap,30);
            //更替完成删除tmp目录
            DeleteAll("tmp");
            //4.提示升级成功，并打开运行client
            //全部更新完成，更新本地md5文件
            SaveMd5("lmd5.nax",localmap);
            localmap.clear();
            TextAreaMessage.append("更新完成...\n");
            TextAreaMessage.setCaretPosition(TextAreaMessage.getText().length());
            File smd5 = new File("smd5.nax");
            smd5.delete();
            status = 1;
        }catch(Exception e){
            e.printStackTrace();
            System.out.println(e.getMessage());
            status = -1;
            TextAreaMessage.append(e.getMessage());
            TextAreaMessage.setCaretPosition(TextAreaMessage.getText().length());
            if(e.getClass() == SocketTimeoutException.class){
                //提示连接超时
                JOptionPane.showMessageDialog(null, "连接超时。\n请继续使用旧版本并确保填写正确的ip与port。\n若该客户端版本是在校园网的网站内下载的，请在校园网环境内重试。\n如果还不行，请联系教师或者管理员。");
            }else if(e.getClass() == ConnectException.class){
                //提示网络连接错误
                JOptionPane.showMessageDialog(null, "网络拒绝访问。\n请继续使用旧版本并填写正确的ip与port。\n若该客户端版本是在校园网的网站内下载的，请在校园网环境内重试。");
            }
        }finally{
            isworking = false;
        }

    }
    private void StartDownloadFiles(Map<String, String> maptodownload, Map<String, String> servermap, int total_progress) throws Exception{
        TextAreaMessage.setText("正在下载更新文件...\n");
        if(maptodownload.size() > 0)
            this.setVisible(true);
        File tmpDir = new File("tmp");
        Map<String, String> map_hasDownload = new HashMap<>();
        //临时文件夹不存在则创建
        if(!tmpDir.exists())
            tmpDir.mkdir();
        //读取tmp目录下tmp文件，
        File tmpfile = new File("tmp/tmp");
        if(tmpfile.exists()){
            try{
                ObjectInputStream ois = new ObjectInputStream(new FileInputStream(tmpfile));
                map_hasDownload.putAll((HashMap<String, String>)ois.readObject());
                ois.close();
            }catch(EOFException ee){
                System.out.println("FileEmpty");
                throw ee;
            }
        }else{
            tmpfile.createNewFile();//没有临时记录文件则创建新文件
        }
        //开始循环下载
        Iterator iter = maptodownload.entrySet().iterator();
        int file_num = maptodownload.size();
        int counter = 0; int has_num = 0;int k = 0;
        try{
            while(iter.hasNext()){
                Map.Entry entry_local = (Map.Entry)iter.next();
                String key = (String)entry_local.getKey();
                String val = (String)entry_local.getValue();
                String tmpPath = "tmp\\"+val.split("\\\\.\\\\")[1];
                String serverMD5 = servermap.get(key);
                TextAreaMessage.append("正在下载..."+val.split("\\\\.\\\\")[1]+"\n");
                TextAreaMessage.setCaretPosition(TextAreaMessage.getText().length());
                if(map_hasDownload.containsKey(tmpPath)){
                    //对比md5值
                    if(serverMD5.equals(map_hasDownload.get(tmpPath)))
                    {
                        //别忘了计数
                        counter++;
                        map_hasDownload.put(tmpPath, serverMD5);
                        k = (int)(1.0*total_progress/file_num*counter - has_num);
                        if(k >= 1)
                        {
                            SetWorkingProgress(k);
                            has_num+=k;
                        }
                        continue;
                    }
                    else
                        HttpGetFile(EditAdress.getText(), tmpPath, key);
                }
                else
                    HttpGetFile(EditAdress.getText(), tmpPath, key);
                //进度条计数
                counter++;
                map_hasDownload.put(tmpPath, serverMD5);
                k = (int)(1.0*total_progress/file_num*counter - has_num);
                if(k >= 1)
                {
                    SetWorkingProgress(k);
                    has_num+=k;
                }               
            }
            ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(tmpfile));
            oos.writeObject(map_hasDownload);
            oos.close();
        }catch(Exception e){
            //写入tmp文件
            ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(tmpfile));
            oos.writeObject(map_hasDownload);
            oos.close();
            //抛错，主流程控制
            throw e;
        }
        
    }
    private void GetPath(Map<String, String> target, Map<String, String> maptodownload, int total_progress,String local_libpoint,String server_libpoint ) throws Exception {
        TextAreaMessage.append("正在解析路径...\n");
        Iterator iter_server = maptodownload.entrySet().iterator();
        int file_num = maptodownload.size();
        int counter = 0; int has_num = 0;int k = 0;
        while (iter_server.hasNext()) {
            Map.Entry entry_server = (Map.Entry)iter_server.next();
            String path_server = (String)entry_server.getKey();
            String path_local = (String)entry_server.getValue();
            //如何切割并区别目录？
            //-->根据固有目录lib区分切割点
            if("_".equals(path_local)){
                //无该文件，查看lib节点
                String targ = path_server.split(server_libpoint.replaceAll("\\\\", "\\\\\\\\"))[1];
                String saveLocation = local_libpoint + File.separator + targ;
                TextAreaMessage.append(path_server+"-->"+saveLocation+"\n");
                TextAreaMessage.setCaretPosition(TextAreaMessage.getText().length());
                target.put(path_server, saveLocation);
            }else{
                //有该文件，也是切割lib点
                String saveLocation = path_local.split(local_libpoint.replaceAll("\\\\", "\\\\\\\\"))[1];
                saveLocation = local_libpoint + File.separator + saveLocation;
                TextAreaMessage.append(path_server+"-->"+saveLocation+"\n");
                TextAreaMessage.setCaretPosition(TextAreaMessage.getText().length());
                target.put(path_server, saveLocation);
            }
            counter++;
            k = (int)(1.0*total_progress/file_num*counter - has_num);
            if(k >= 1)//可能不等于1
            {
             	SetWorkingProgress(k);
               	has_num += k;
            }
        }
    }
    private void SaveMd5(String lmd5nax, Map<String, String> localmap) throws IOException {
        File lmd5 = new File(lmd5nax);
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(lmd5));
	oos.writeObject(localmap);
	oos.close();
    }
    private void SetWorkingProgress(int i) throws Exception{
        workingprogress += i;
        progressbar.setValue(workingprogress);
    }
    private void StartReplaceFiles(Map<String, String> pathMap, int total_progress) throws IOException, ClassNotFoundException, Exception {
        Map<String, String> map_hasDownload = new HashMap<>();
        TextAreaMessage.setText("");
        //读取tmp目录下tmp文件，
        File tmpfile = new File("tmp/tmp");
        if(tmpfile.exists()){
            try{
                ObjectInputStream ois = new ObjectInputStream(new FileInputStream(tmpfile));
                map_hasDownload.putAll((HashMap<String, String>)ois.readObject());
                ois.close();
            }catch(EOFException ee){
                System.out.println("FileEmpty");
            }
        }else{
            return;//无文件即为未完成或无更新文件
        }
        Iterator iter = map_hasDownload.entrySet().iterator();
        byte[] buffer = new byte[1024];int btcount = 0;
        int counter = 0;int k = 0;int has_num = 0;
        int file_num = map_hasDownload.size();
        while (iter.hasNext()) {
            Map.Entry entry = (Map.Entry)iter.next();
            String tmppath = (String)entry.getKey(); 
            System.out.println(tmppath);
            File target = new File(tmppath.split("tmp\\\\\\\\")[1]);
            System.out.println(target+"替换路径");
            if(target.exists())
            {
                target.delete();
                target.createNewFile();
            }else{
                if(target.getParentFile() != null && !target.getParentFile().exists())
                    target.getParentFile().mkdirs();
                target.createNewFile();
            }
            TextAreaMessage.append("正在替换文件..."+target.getName()+"\n");
            TextAreaMessage.setCaretPosition(TextAreaMessage.getText().length());
            File tmpFile = new File(tmppath);
            FileInputStream fis = new FileInputStream(tmpFile);
            FileOutputStream fos = new FileOutputStream(target);
            BufferedInputStream bis = new BufferedInputStream(fis);
            BufferedOutputStream bos = new BufferedOutputStream(fos);
            while((btcount = bis.read(buffer)) != -1){
                bos.write(buffer, 0, btcount);
            }
            bos.close();
            bis.close();
            fos.close();
            fis.close();
            counter++;
            k = (int)(1.0*total_progress/file_num*counter - has_num);
            if(k >= 1)
            {
                SetWorkingProgress(k);
                has_num+=k;
            }
        }
    }
    private void DeleteAll(String root) {
	File file = new File(root);
	DeleteDir(file);
	file.deleteOnExit();
    }
    private Boolean DeleteDir(File file) {
	if(file.isDirectory()){
            String[] list = file.list();
            Boolean res = true;
            for (int i=0; i<list.length; i++) {
                boolean success = DeleteDir(new File(file, list[i]));
                if (!success) {
                    res = false;
                }
            }
            file.delete();
            return res;
        }else
            return file.delete();
    }
    private void HttpGetFile(String ipandport, String saveFilePath, String requestNameString) throws Exception  {
        //http://localhost:8080/oj/UpLoadFileAction!UpLoad.action
        String encfilename = new String(Base64.encodeBase64(requestNameString.getBytes("utf-8")));
        URL url = new URL("http://"+ipandport+"/oj/SoftwareVersionMAction!DownLoadFile.action?DFileName="+encfilename);
        URLConnection u = url.openConnection();
        HttpURLConnection connection = (HttpURLConnection)u;
        connection.setReadTimeout(5000);
        connection.connect();
        BufferedInputStream bin = new BufferedInputStream(connection.getInputStream());
        byte[] buff = new byte[1024];
        File file = new File(saveFilePath);
        //无目录则创建新文件夹
//        if(saveFilePath.contains("\\.\\")){
//            String[] spts = saveFilePath.split("\\\\");
//            String dirPath = saveFilePath.split("\\\\"+spts[spts.length-1])[0];
//            File dir = new File(dirPath);
//            if(!dir.exists())
//                dir.mkdirs();
//        }
        if(file.exists())
        {
            file.delete();
            file.createNewFile();
        }else{
            if(file.getParentFile()!= null && !file.getParentFile().exists())
                file.getParentFile().mkdirs();
            file.createNewFile();
        }
        FileOutputStream fos = new FileOutputStream(file);
        int size;
        while((size = bin.read(buff))!=-1){
            fos.write(buff,0,size);
        }
        fos.flush();
        fos.close();
        bin.close();
        connection.disconnect();
    }
}
